"use strict";(self.webpackChunkpmdm=self.webpackChunkpmdm||[]).push([[5641],{13561:(e,a,i)=>{i.d(a,{A:()=>n});const n=i.p+"assets/images/arquitectura-mvvm-repository-b75154b43b97f9104e27b71e1159a6a3.png"},25349:(e,a,i)=>{i.d(a,{A:()=>n});const n=i.p+"assets/images/diag-secuencia-inicial-96449275fb10804401b4748d3232e89e.png"},28453:(e,a,i)=>{i.d(a,{R:()=>o,x:()=>s});var n=i(96540);const l={},r=n.createContext(l);function o(e){const a=n.useContext(r);return n.useMemo(function(){return"function"==typeof e?e(a):{...a,...e}},[a,e])}function s(e){let a;return a=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:o(e.components),n.createElement(r.Provider,{value:a},e.children)}},29627:(e,a,i)=>{i.d(a,{A:()=>n});const n=i.p+"assets/images/diagrama-sec-mvvm-repo-ff96151f942de931bb82fe88e876b462.png"},30165:(e,a,i)=>{i.d(a,{A:()=>n});const n=i.p+"assets/images/girar-pantalla-d5416074d19b7503f4aa5beba3d3320e.gif"},30445:(e,a,i)=>{i.d(a,{A:()=>n});const n=i.p+"assets/images/demo-searchview-66669ccb2b7e01485a7e8b695bbb8761.gif"},41544:(e,a,i)=>{i.r(a),i.d(a,{assets:()=>t,contentTitle:()=>s,default:()=>m,frontMatter:()=>o,metadata:()=>n,toc:()=>d});const n=JSON.parse('{"id":"pmdm_2526/ut3_interfaces_usuario_navegacion/mvvm","title":"Arquitectura MVVM","description":"MVVM (Model-View-ViewModel) es la arquitectura recomendada por Android para organizar el c\xf3digo de forma modular, manteniendo una separaci\xf3n clara entre la interfaz de usuario, la l\xf3gica de presentaci\xf3n y el acceso a los datos.","source":"@site/docs/01_pmdm_2526/ut3_interfaces_usuario_navegacion/4-mvvm.md","sourceDirName":"01_pmdm_2526/ut3_interfaces_usuario_navegacion","slug":"/pmdm_2526/ut3_interfaces_usuario_navegacion/mvvm","permalink":"/DevTacora/docs/pmdm_2526/ut3_interfaces_usuario_navegacion/mvvm","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"title":"Arquitectura MVVM","sidebar_position":4,"description":"MVVM (Model-View-ViewModel) es la arquitectura recomendada por Android para organizar el c\xf3digo de forma modular, manteniendo una separaci\xf3n clara entre la interfaz de usuario, la l\xf3gica de presentaci\xf3n y el acceso a los datos.","keywords":["Android","MVVM","ViewModel","LiveData","Repository","Arquitectura","Jetpack"]},"sidebar":"pmdm_2526_Sidebar","previous":{"title":"RecyclerView","permalink":"/DevTacora/docs/pmdm_2526/ut3_interfaces_usuario_navegacion/recycler-view"},"next":{"title":"UT4. Componentes avanzados","permalink":"/DevTacora/docs/category/ut4-componentes-avanzados"}}');var l=i(74848),r=i(28453);const o={title:"Arquitectura MVVM",sidebar_position:4,description:"MVVM (Model-View-ViewModel) es la arquitectura recomendada por Android para organizar el c\xf3digo de forma modular, manteniendo una separaci\xf3n clara entre la interfaz de usuario, la l\xf3gica de presentaci\xf3n y el acceso a los datos.",keywords:["Android","MVVM","ViewModel","LiveData","Repository","Arquitectura","Jetpack"]},s=void 0,t={},d=[{value:"Arquitectura previa",id:"arquitectura-previa",level:2},{value:"Problema: P\xe9rdida de datos al girar la pantalla",id:"problema-p\xe9rdida-de-datos-al-girar-la-pantalla",level:3},{value:"Arquitectura MVVM con Repository",id:"arquitectura-mvvm-con-repository",level:2},{value:"Estructura general",id:"estructura-general",level:3},{value:"Ciclo de vida del ViewModel",id:"ciclo-de-vida-del-viewmodel",level:3},{value:"LiveData",id:"livedata",level:3},{value:"\xbfPor qu\xe9 el ViewModel expone LiveData?",id:"por-qu\xe9-el-viewmodel-expone-livedata",level:4},{value:"Tutorial de uso - Fragment con RecyclerView",id:"tutorial-de-uso---fragment-con-recyclerview",level:2},{value:"Crear el ViewModel",id:"crear-el-viewmodel",level:3},{value:"Modificar el Fragment principal",id:"modificar-el-fragment-principal",level:3},{value:"Tutorial de uso - Navegaci\xf3n pantalla detalle",id:"tutorial-de-uso---navegaci\xf3n-pantalla-detalle",level:2},{value:"Modificar el ViewModel",id:"modificar-el-viewmodel",level:3},{value:"Modificar el adaptador para seleccionar el elemento",id:"modificar-el-adaptador-para-seleccionar-el-elemento",level:3},{value:"Recuperar el objeto desde el fragmento de detalle",id:"recuperar-el-objeto-desde-el-fragmento-de-detalle",level:3},{value:"Modificaciones en el grafo de navegaci\xf3n",id:"modificaciones-en-el-grafo-de-navegaci\xf3n",level:3},{value:"Tutorial de uso \u2013 Eliminar un elemento mediante gestos",id:"tutorial-de-uso--eliminar-un-elemento-mediante-gestos",level:2},{value:"L\xf3gica de eliminaci\xf3n en el ViewModel",id:"l\xf3gica-de-eliminaci\xf3n-en-el-viewmodel",level:3},{value:"Configurar el gesto en el Fragment",id:"configurar-el-gesto-en-el-fragment",level:3},{value:"Tutorial de uso \u2013 Marcar como favorito",id:"tutorial-de-uso--marcar-como-favorito",level:2},{value:"Modificar el layout del ViewHolder",id:"modificar-el-layout-del-viewholder",level:3},{value:"Modificar el modelo (<code>Animal.java</code>)",id:"modificar-el-modelo-animaljava",level:3},{value:"Cambios en el Adapter",id:"cambios-en-el-adapter",level:3},{value:"Gestionar favoritos en el ViewModel y Repisitory",id:"gestionar-favoritos-en-el-viewmodel-y-repisitory",level:3},{value:"Tutorial de uso \u2013 B\xfasqueda de elementos",id:"tutorial-de-uso--b\xfasqueda-de-elementos",level:2},{value:"Layout con SearchView",id:"layout-con-searchview",level:3},{value:"Activar la b\xfasqueda desde el Fragment",id:"activar-la-b\xfasqueda-desde-el-fragment",level:3},{value:"Filtrar elementos en ViewModel y Repository",id:"filtrar-elementos-en-viewmodel-y-repository",level:3}];function c(e){const a={admonition:"admonition",blockquote:"blockquote",br:"br",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",hr:"hr",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,l.jsxs)("div",{class:"justify-text",children:[(0,l.jsxs)(a.p,{children:["La ",(0,l.jsx)(a.strong,{children:"arquitectura MVVM (Model\u2013View\u2013ViewModel)"})," es un patr\xf3n de dise\xf1o recomendado por Android para ",(0,l.jsx)(a.strong,{children:"organizar el c\xf3digo de forma clara y mantenible"}),", separando la l\xf3gica de la interfaz de usuario."]}),(0,l.jsx)(a.p,{children:"Sus tres componentes principales son:"}),(0,l.jsxs)(a.ul,{children:["\n",(0,l.jsxs)(a.li,{children:[(0,l.jsx)(a.strong,{children:"Model"})," \u2192 Representa los datos y las reglas de negocio (normalmente clases POJO o entidades de base de datos)."]}),"\n",(0,l.jsxs)(a.li,{children:[(0,l.jsx)(a.strong,{children:"View"})," \u2192 Es la interfaz de usuario (Activities o Fragments). Solo muestra la informaci\xf3n y responde a las acciones del usuario."]}),"\n",(0,l.jsxs)(a.li,{children:[(0,l.jsx)(a.strong,{children:"ViewModel"})," \u2192 Act\xfaa como intermediario entre la View y el Model. Mantiene los datos, gestiona la l\xf3gica de presentaci\xf3n y expone la informaci\xf3n mediante ",(0,l.jsx)(a.strong,{children:"LiveData"})," para que la vista se actualice autom\xe1ticamente."]}),"\n"]}),(0,l.jsxs)(a.p,{children:["En la pr\xe1ctica, en Android moderno, se suele incluir tambi\xe9n un ",(0,l.jsx)(a.strong,{children:"Repository"}),", que se encarga de obtener los datos (de una API, una base de datos o memoria local):"]}),(0,l.jsx)(a.p,{children:(0,l.jsx)(a.img,{alt:"Arquitectura MVVM",src:i(13561).A+"",width:"960",height:"720"})}),(0,l.jsx)(a.h2,{id:"arquitectura-previa",children:"Arquitectura previa"}),(0,l.jsxs)(a.p,{children:["En el apartado anterior aprendimos a mostrar listas din\xe1micas de datos con ",(0,l.jsx)(a.strong,{children:"RecyclerView"}),", utilizando un ",(0,l.jsx)(a.strong,{children:"Repository"})," como fuente de datos para nuestros animales."]}),(0,l.jsx)(a.p,{children:"La estructura que ten\xedamos era algo as\xed:"}),(0,l.jsx)(a.p,{children:(0,l.jsx)(a.img,{alt:"Diagrama secuencia inicial",src:i(25349).A+"",width:"1384",height:"584"})}),(0,l.jsxs)(a.p,{children:["El ",(0,l.jsx)(a.code,{children:"Fragment"})," obten\xeda directamente los datos del ",(0,l.jsx)(a.code,{children:"Repository"}),", los mostraba en pantalla, y tambi\xe9n gestionaba acciones como eliminar elementos."]}),(0,l.jsxs)(a.p,{children:["A primera vista, esto ",(0,l.jsx)(a.strong,{children:"parece funcionar perfectamente"}),"\u2026 pero en cuanto la app crece o intentamos simular un caso real, consumiendo datos de una API o base de datos en la nube, ",(0,l.jsx)(a.strong,{children:"aparecen varios problemas importantes."})]}),(0,l.jsx)(a.h3,{id:"problema-p\xe9rdida-de-datos-al-girar-la-pantalla",children:"Problema: P\xe9rdida de datos al girar la pantalla"}),(0,l.jsxs)(a.p,{children:["Uno de los efectos visibles es lo que ocurre al ",(0,l.jsx)(a.strong,{children:"girar el dispositivo"}),".\nAndroid destruye y recrea el ",(0,l.jsx)(a.code,{children:"Fragment"}),", lo que implica que ",(0,l.jsx)(a.strong,{children:"vuelve a ejecutar su c\xf3digo desde cero"}),", incluido este fragmento:"]}),(0,l.jsx)(a.pre,{children:(0,l.jsx)(a.code,{className:"language-java",children:"repository = new AnimalesRepository();\nList<Animal> listaAnimales = repository.getAnimales();\n"})}),(0,l.jsx)(a.p,{children:"Esto significa que:"}),(0,l.jsxs)(a.ul,{children:["\n",(0,l.jsxs)(a.li,{children:["Se crea ",(0,l.jsx)(a.strong,{children:"un nuevo Repository"})," cada vez que se recrea el fragmento."]}),"\n",(0,l.jsxs)(a.li,{children:["Los ",(0,l.jsx)(a.strong,{children:"animales eliminados reaparecen"}),", porque la lista vuelve a su estado original."]}),"\n"]}),(0,l.jsx)(a.p,{children:(0,l.jsx)(a.img,{alt:"Demo girar pantalla",src:i(30165).A+"",width:"958",height:"898"})}),(0,l.jsx)(a.p,{children:"Para solucionar este problema y otros que surgir\xedan con el consumo de APIs o bases de datos, necesitamos una capa intermedia que:"}),(0,l.jsxs)(a.ul,{children:["\n",(0,l.jsx)(a.li,{children:"Mantenga los datos y su estado a lo largo del ciclo de vida."}),"\n",(0,l.jsx)(a.li,{children:"Ejecute las operaciones de forma as\xedncrona, sin congelar la interfaz."}),"\n",(0,l.jsx)(a.li,{children:"Permita que la vista simplemente observe los cambios y se actualice sola."}),"\n"]}),(0,l.jsxs)(a.p,{children:["Esa capa intermedia es el ",(0,l.jsx)(a.strong,{children:"ViewModel"}),", eje central del patr\xf3n ",(0,l.jsx)(a.strong,{children:"MVVM"})," (",(0,l.jsx)(a.em,{children:"Model\u2013View\u2013ViewModel"}),"), que aprenderemos a implementar en este tema."]}),(0,l.jsx)(a.hr,{}),(0,l.jsx)(a.h2,{id:"arquitectura-mvvm-con-repository",children:"Arquitectura MVVM con Repository"}),(0,l.jsxs)(a.p,{children:["El patr\xf3n ",(0,l.jsx)(a.strong,{children:"MVVM (Model\u2013View\u2013ViewModel)"})," nos permite ",(0,l.jsx)(a.strong,{children:"organizar el c\xf3digo en capas"})," bien definidas, para que cada una tenga una \xfanica responsabilidad. De esta forma, conseguimos aplicaciones m\xe1s ",(0,l.jsx)(a.strong,{children:"robustas, mantenibles y escalables"}),"."]}),(0,l.jsx)(a.p,{children:"Sus objetivos principales son:"}),(0,l.jsxs)(a.ol,{children:["\n",(0,l.jsxs)(a.li,{children:[(0,l.jsx)(a.strong,{children:"Separar responsabilidades"}),": cada capa tiene una funci\xf3n concreta y no depende directamente de las dem\xe1s."]}),"\n",(0,l.jsxs)(a.li,{children:[(0,l.jsx)(a.strong,{children:"Mantener los datos al girar la pantalla o cambiar de configuraci\xf3n"}),"."]}),"\n",(0,l.jsxs)(a.li,{children:[(0,l.jsx)(a.strong,{children:"Evitar bloqueos en la interfaz"}),", ejecutando las operaciones de datos fuera del hilo principal."]}),"\n",(0,l.jsxs)(a.li,{children:[(0,l.jsx)(a.strong,{children:"Actualizar autom\xe1ticamente la interfaz"})," cuando cambian los datos, gracias a ",(0,l.jsx)(a.code,{children:"LiveData"}),"."]}),"\n",(0,l.jsxs)(a.li,{children:[(0,l.jsx)(a.strong,{children:"Preparar la app"})," para integrarse f\xe1cilmente con APIs, bases de datos locales (Room) o Firebase."]}),"\n"]}),(0,l.jsx)(a.hr,{}),(0,l.jsx)(a.h3,{id:"estructura-general",children:"Estructura general"}),(0,l.jsx)(a.p,{children:"En Android moderno, la estructura de MVVM con Repository sigue este esquema:"}),(0,l.jsx)(a.p,{children:(0,l.jsx)(a.img,{alt:"Diagrama secuencia MVVM con Repository",src:i(29627).A+"",width:"2222",height:"1554"})}),(0,l.jsxs)(a.p,{children:["Cada capa tiene un ",(0,l.jsx)(a.strong,{children:"rol bien definido"}),":"]}),(0,l.jsxs)(a.table,{children:[(0,l.jsx)(a.thead,{children:(0,l.jsxs)(a.tr,{children:[(0,l.jsx)(a.th,{children:"Capa"}),(0,l.jsx)(a.th,{children:"Rol principal"}),(0,l.jsx)(a.th,{children:"Qu\xe9 contiene"})]})}),(0,l.jsxs)(a.tbody,{children:[(0,l.jsxs)(a.tr,{children:[(0,l.jsx)(a.td,{children:(0,l.jsx)(a.strong,{children:"View (Activity / Fragment)"})}),(0,l.jsxs)(a.td,{children:["Muestra los datos y gestiona la interacci\xf3n del usuario. Observa los cambios en el ",(0,l.jsx)(a.code,{children:"LiveData"})," expuesto por el ViewModel."]}),(0,l.jsx)(a.td,{children:"C\xf3digo de interfaz (layouts, bindings, adapters, listeners)."})]}),(0,l.jsxs)(a.tr,{children:[(0,l.jsx)(a.td,{children:(0,l.jsx)(a.strong,{children:"ViewModel"})}),(0,l.jsx)(a.td,{children:"Mantiene los datos para la interfaz y gestiona la l\xf3gica de presentaci\xf3n. Sobrevive a los cambios de configuraci\xf3n y se comunica con el Repository."}),(0,l.jsxs)(a.td,{children:["Propiedades ",(0,l.jsx)(a.code,{children:"LiveData"}),", m\xe9todos de acceso a datos, l\xf3gica de presentaci\xf3n."]})]}),(0,l.jsxs)(a.tr,{children:[(0,l.jsx)(a.td,{children:(0,l.jsx)(a.strong,{children:"Repository"})}),(0,l.jsx)(a.td,{children:"Proporciona los datos desde su fuente (API, base de datos o memoria). Es el intermediario entre el ViewModel y el origen real de los datos."}),(0,l.jsx)(a.td,{children:"M\xe9todos para obtener, insertar o eliminar informaci\xf3n."})]}),(0,l.jsxs)(a.tr,{children:[(0,l.jsx)(a.td,{children:(0,l.jsx)(a.strong,{children:"Model (POJO)"})}),(0,l.jsx)(a.td,{children:"Define la estructura de los datos que maneja la app."}),(0,l.jsxs)(a.td,{children:["Clases simples (por ejemplo, ",(0,l.jsx)(a.code,{children:"Animal.java"}),")."]})]})]})]}),(0,l.jsx)(a.hr,{}),(0,l.jsx)(a.h3,{id:"ciclo-de-vida-del-viewmodel",children:"Ciclo de vida del ViewModel"}),(0,l.jsxs)(a.p,{children:["Una de las grandes ventajas del ViewModel es que ",(0,l.jsx)(a.strong,{children:"mantiene los datos durante los cambios de configuraci\xf3n"}),", como la rotaci\xf3n de pantalla.",(0,l.jsx)(a.br,{}),"\n","El ViewModel vive mientras la Activity est\xe9 activa, y ",(0,l.jsx)(a.strong,{children:"solo se destruye cuando realmente se elimina del sistema"}),". Los datos del ViewModel son compartidos entre todos los Fragments contenidos en una misma Activity."]}),(0,l.jsx)(a.p,{children:(0,l.jsx)(a.img,{alt:"Ciclo de vida del ViewModel",src:i(92588).A+"",width:"522",height:"543"})}),(0,l.jsx)(a.p,{children:"En el esquema anterior, podemos observar:"}),(0,l.jsxs)(a.ul,{children:["\n",(0,l.jsxs)(a.li,{children:["Cuando se ",(0,l.jsx)(a.strong,{children:"crea la Activity"}),", tambi\xe9n se crea el ",(0,l.jsx)(a.code,{children:"ViewModel"})," asociado."]}),"\n",(0,l.jsxs)(a.li,{children:["Si la ",(0,l.jsx)(a.strong,{children:"Activity se rota"}),", Android destruye y recrea la vista (",(0,l.jsx)(a.code,{children:"onDestroy()"})," \u2192 ",(0,l.jsx)(a.code,{children:"onCreate()"}),"),",(0,l.jsx)(a.br,{}),"\n","pero ",(0,l.jsx)(a.strong,{children:"mantiene el mismo ViewModel"}),", que conserva los datos cargados."]}),"\n",(0,l.jsxs)(a.li,{children:["Solo cuando la Activity finaliza por completo (",(0,l.jsx)(a.code,{children:"finish()"}),"), se llama al m\xe9todo ",(0,l.jsx)(a.code,{children:"onCleared()"})," del ViewModel, liberando recursos."]}),"\n"]}),(0,l.jsxs)(a.p,{children:["Esto significa que, ",(0,l.jsx)(a.strong,{children:"a diferencia del Fragment o la Activity"}),", el ViewModel no se destruye en cada recreaci\xf3n, lo que evita perder el estado de los datos."]}),(0,l.jsx)(a.hr,{}),(0,l.jsx)(a.h3,{id:"livedata",children:"LiveData"}),(0,l.jsxs)(a.p,{children:["Una de las piezas clave del patr\xf3n ",(0,l.jsx)(a.strong,{children:"MVVM"})," en Android es ",(0,l.jsx)(a.strong,{children:"LiveData"}),", una clase observable que forma parte de las ",(0,l.jsx)(a.strong,{children:"Architecture Components"})," de Jetpack.",(0,l.jsx)(a.br,{}),"\n","Su funci\xf3n es permitir que los datos del ",(0,l.jsx)(a.strong,{children:"ViewModel"})," se ",(0,l.jsx)(a.strong,{children:"comuniquen autom\xe1ticamente con la interfaz (View)"})," de forma ",(0,l.jsx)(a.strong,{children:"reactiva"})," y ",(0,l.jsx)(a.strong,{children:"segura respecto al ciclo de vida"}),"."]}),(0,l.jsxs)(a.p,{children:[(0,l.jsx)(a.code,{children:"LiveData"})," es un ",(0,l.jsx)(a.strong,{children:"contenedor de datos observable"}),", es decir, una clase que ",(0,l.jsx)(a.strong,{children:"notifica autom\xe1ticamente a sus observadores"})," (normalmente Fragments o Activities) cuando los datos cambian."]}),(0,l.jsxs)(a.p,{children:["A diferencia de un ",(0,l.jsx)(a.code,{children:"List"})," o una variable normal, ",(0,l.jsx)(a.code,{children:"LiveData"}),":"]}),(0,l.jsxs)(a.ul,{children:["\n",(0,l.jsxs)(a.li,{children:["Est\xe1 ",(0,l.jsx)(a.strong,{children:"vinculado al ciclo de vida"})," de la vista (solo notifica si est\xe1 activa)."]}),"\n",(0,l.jsxs)(a.li,{children:[(0,l.jsx)(a.strong,{children:"Evita fugas de memoria"}),", ya que deja de emitir cuando el fragmento se destruye."]}),"\n",(0,l.jsxs)(a.li,{children:[(0,l.jsx)(a.strong,{children:"Mantiene el \xfaltimo valor"}),", por lo que si la vista se recrea (por ejemplo, al girar la pantalla), el nuevo fragment recibe autom\xe1ticamente los datos actuales sin volver a cargarlos."]}),"\n"]}),(0,l.jsx)(a.p,{children:"Existen dos tipos principales:"}),(0,l.jsxs)(a.table,{children:[(0,l.jsx)(a.thead,{children:(0,l.jsxs)(a.tr,{children:[(0,l.jsx)(a.th,{children:"Tipo"}),(0,l.jsx)(a.th,{children:"Descripci\xf3n"}),(0,l.jsx)(a.th,{children:"Qui\xe9n puede modificarlo"})]})}),(0,l.jsxs)(a.tbody,{children:[(0,l.jsxs)(a.tr,{children:[(0,l.jsx)(a.td,{children:(0,l.jsx)(a.strong,{children:"LiveData<T>"})}),(0,l.jsx)(a.td,{children:"Dato observable de solo lectura. La vista solo puede observarlo."}),(0,l.jsx)(a.td,{children:"Nadie (solo lectura)."})]}),(0,l.jsxs)(a.tr,{children:[(0,l.jsx)(a.td,{children:(0,l.jsx)(a.strong,{children:"MutableLiveData<T>"})}),(0,l.jsxs)(a.td,{children:["Versi\xf3n modificable del LiveData. Permite actualizar su valor mediante ",(0,l.jsx)(a.code,{children:"setValue()"})," o ",(0,l.jsx)(a.code,{children:"postValue()"}),"."]}),(0,l.jsxs)(a.td,{children:["El ",(0,l.jsx)(a.strong,{children:"ViewModel"}),"."]})]})]})]}),(0,l.jsx)(a.p,{children:"Ejemplo:"}),(0,l.jsx)(a.pre,{children:(0,l.jsx)(a.code,{className:"language-java",metastring:'title="AnimalesViewModel.java"',children:"public class AnimalesViewModel extends ViewModel {\n    private final AnimalesRepository repository;\n    // Lo hacemos Mutable porque cambiar\xe1 su valor (p.e. cuando eliminamos un Animal)\n    private final MutableLiveData<List<Animal>> animales = new MutableLiveData<>();\n\n    public AnimalesViewModel() {\n        repository = new AnimalesRepository();\n        animales.setValue(repository.getAnimales());\n    }\n\n    public void eliminarAnimal(Animal animal) {\n        repository.eliminarAnimal(animal);\n        animales.setValue(repository.getAnimales()); // actualiza LiveData\n    }\n}\n"})}),(0,l.jsxs)(a.p,{children:["Y en el ",(0,l.jsx)(a.code,{children:"Fragment"})," simplemente se observa ese ",(0,l.jsx)(a.code,{children:"LiveData"}),":"]}),(0,l.jsx)(a.pre,{children:(0,l.jsx)(a.code,{className:"language-java",metastring:'title="AnimalesFragment.java"',children:"viewModel.animales.observe(getViewLifecycleOwner(), lista -> {\n    adapter.establecerLista(lista); // Actualiza el RecyclerView\n});\n"})}),(0,l.jsxs)(a.blockquote,{children:["\n",(0,l.jsxs)(a.p,{children:["\ud83d\udca1 Cada vez que el ViewModel actualiza el ",(0,l.jsx)(a.code,{children:"MutableLiveData"}),", el LiveData ",(0,l.jsx)(a.strong,{children:"emite autom\xe1ticamente los cambios"}),", y la vista se actualiza sin tener que hacerlo manualmente."]}),"\n"]}),(0,l.jsx)(a.h4,{id:"por-qu\xe9-el-viewmodel-expone-livedata",children:"\xbfPor qu\xe9 el ViewModel expone LiveData?"}),(0,l.jsxs)(a.p,{children:["Porque permite que la ",(0,l.jsx)(a.strong,{children:"vista observe los datos sin controlarlos directamente"}),". Esto refuerza la ",(0,l.jsx)(a.strong,{children:"separaci\xf3n de responsabilidades"}),":"]}),(0,l.jsxs)(a.ul,{children:["\n",(0,l.jsxs)(a.li,{children:["El ",(0,l.jsx)(a.strong,{children:"ViewModel"})," gestiona y modifica los datos."]}),"\n",(0,l.jsxs)(a.li,{children:["La ",(0,l.jsx)(a.strong,{children:"View"})," solo los muestra y reacciona a los cambios."]}),"\n"]}),(0,l.jsx)(a.p,{children:"Adem\xe1s:"}),(0,l.jsxs)(a.ul,{children:["\n",(0,l.jsxs)(a.li,{children:["Si el usuario gira el dispositivo, el ",(0,l.jsx)(a.code,{children:"LiveData"})," ",(0,l.jsx)(a.strong,{children:"mantiene el valor actual"}),", sin tener que volver a hacer la petici\xf3n para recuperar los animales."]}),"\n",(0,l.jsxs)(a.li,{children:["Si se a\xf1aden nuevos observadores (por ejemplo, otro fragmento), estos ",(0,l.jsx)(a.strong,{children:"reciben inmediatamente el \xfaltimo dato emitido"}),"."]}),"\n"]}),(0,l.jsx)(a.hr,{}),(0,l.jsx)(a.h2,{id:"tutorial-de-uso---fragment-con-recyclerview",children:"Tutorial de uso - Fragment con RecyclerView"}),(0,l.jsxs)(a.p,{children:["A continuaci\xf3n implementaremos esta arquitectura paso a paso sobre nuestra aplicaci\xf3n de animales, transformando el acceso directo al ",(0,l.jsx)(a.code,{children:"Repository"})," en un flujo completo con ",(0,l.jsx)(a.strong,{children:"ViewModel + LiveData"}),"."]}),(0,l.jsxs)(a.p,{children:["Partiremos del proyecto anterior, que ya muestra una lista de animales en un ",(0,l.jsx)(a.code,{children:"RecyclerView"}),", y lo adaptaremos al patr\xf3n ",(0,l.jsx)(a.strong,{children:"MVVM"}),"."]}),(0,l.jsxs)(a.admonition,{title:"Importante",type:"warning",children:[(0,l.jsxs)(a.p,{children:["Los siguientes elementos ",(0,l.jsx)(a.strong,{children:"no se modifican"})," respecto a la versi\xf3n anterior:"]}),(0,l.jsxs)(a.ul,{children:["\n",(0,l.jsxs)(a.li,{children:[(0,l.jsx)(a.strong,{children:"Modelo"}),": ",(0,l.jsx)(a.code,{children:"Animal.java"})]}),"\n",(0,l.jsxs)(a.li,{children:[(0,l.jsx)(a.strong,{children:"Repository"}),": ",(0,l.jsx)(a.code,{children:"AnimalesRepository.java"})]}),"\n",(0,l.jsxs)(a.li,{children:[(0,l.jsx)(a.strong,{children:"Adaptador y ViewHolder del RecyclerView"}),": ",(0,l.jsx)(a.code,{children:"AnimalesAdapter.java"})," y ",(0,l.jsx)(a.code,{children:"AnimalViewHolder"}),"."]}),"\n",(0,l.jsxs)(a.li,{children:["Las ",(0,l.jsx)(a.strong,{children:"interfaces de usuario (layouts de activity y fragments)"}),"."]}),"\n"]}),(0,l.jsx)(a.p,{children:"Todo su c\xf3digo sigue siendo v\xe1lido y funcional. Por simplificar, en este tutorial solamente se incluir\xe1n las clases que sufren cambios para adaptarse a la nueva arquitectura."})]}),(0,l.jsx)(a.hr,{}),(0,l.jsx)(a.h3,{id:"crear-el-viewmodel",children:"Crear el ViewModel"}),(0,l.jsxs)(a.p,{children:["El ",(0,l.jsx)(a.strong,{children:"ViewModel"})," es el componente que conserva los datos y la l\xf3gica de presentaci\xf3n.",(0,l.jsx)(a.br,{}),"\n","Su objetivo es ",(0,l.jsx)(a.strong,{children:"mantener el estado"})," a lo largo del ciclo de vida del fragmento y ",(0,l.jsx)(a.strong,{children:"exponer los datos"})," mediante un ",(0,l.jsx)(a.code,{children:"MutableLiveData"}),"."]}),(0,l.jsxs)(a.p,{children:["Creamos la clase ",(0,l.jsx)(a.code,{children:"AnimalesViewModel.java"})," dentro del paquete ",(0,l.jsx)(a.code,{children:"viewmodel"}),":"]}),(0,l.jsx)(a.pre,{children:(0,l.jsx)(a.code,{className:"language-java",metastring:'title="AnimalesViewModel.java"',children:"public class AnimalesViewModel extends ViewModel {\n\n    // Ahora tendremos las referencias al repository en el ViewModel, no en el Fragment\n    private AnimalesRepository repository;\n    // LiveData que expone la lista de animales\n    public MutableLiveData<List<Animal>> animales = new MutableLiveData<>();\n\n    public AnimalesViewModel() {\n        // Inicializamos el repository para tener los animales listos\n        repository = new AnimalesRepository();\n    }\n\n    public void obtenerAnimales() {\n        // Recuperamos los animales del repository y los almacenamos en el MLiveData\n        animales.setValue(repository.getAnimales());\n    }\n}\n"})}),(0,l.jsxs)(a.p,{children:["\ud83d\udcd8 ",(0,l.jsx)(a.strong,{children:"Explicaci\xf3n:"})]}),(0,l.jsxs)(a.ul,{children:["\n",(0,l.jsxs)(a.li,{children:["El ",(0,l.jsx)(a.code,{children:"ViewModel"})," se crea una sola vez y ",(0,l.jsx)(a.strong,{children:"se mantiene vivo aunque el Fragment o su Activity se recree"}),"."]}),"\n",(0,l.jsxs)(a.li,{children:[(0,l.jsx)(a.code,{children:"MutableLiveData"})," mantiene la lista de animales y ",(0,l.jsx)(a.strong,{children:"notifica autom\xe1ticamente los cambios"})," a la interfaz."]}),"\n"]}),(0,l.jsx)(a.hr,{}),(0,l.jsx)(a.h3,{id:"modificar-el-fragment-principal",children:"Modificar el Fragment principal"}),(0,l.jsxs)(a.p,{children:["En lugar de acceder directamente al ",(0,l.jsx)(a.code,{children:"Repository"}),", el fragmento obtendr\xe1 una instancia del ",(0,l.jsx)(a.strong,{children:"ViewModel"})," mediante el ",(0,l.jsx)(a.code,{children:"ViewModelProvider"}),".\nLuego, se ",(0,l.jsx)(a.strong,{children:"suscribir\xe1 (observer)"})," al ",(0,l.jsx)(a.code,{children:"LiveData"})," para recibir actualizaciones autom\xe1ticas. Ten en cuenta que hasta que no llames al m\xe9todo ",(0,l.jsx)(a.code,{children:"viewModel.obtenerAnimales()"})," el ",(0,l.jsx)(a.code,{children:"MutableLiveData"})," no cargar\xe1 los animales del ",(0,l.jsx)(a.code,{children:"Repositoy"}),"."]}),(0,l.jsx)(a.admonition,{title:"CODIGO NUEVO",type:"info",children:(0,l.jsx)(a.p,{children:"En el siguiente c\xf3digo est\xe1 subrayado en m\xe1s oscuro aquellas l\xedneas adicionales a\xf1adidas. Ten en cuenta tambi\xe9n que se han eliminado algunas l\xedneas, como la que creaba el repository."})}),(0,l.jsx)(a.pre,{children:(0,l.jsx)(a.code,{className:"language-java",metastring:'title="AnimalesFragment.java"',children:"public class AnimalesFragment extends Fragment {\n\n    private FragmentAnimalesBinding binding;\n    // highlight-next-line\n    private AnimalesViewModel viewModel;\n    private AnimalesAdapter adapter;\n\n    @Override\n    public View onCreateView(LayoutInflater inflater, ViewGroup container,\n                             Bundle savedInstanceState) {\n        binding = FragmentAnimalesBinding.inflate(inflater, container, false);\n        return binding.getRoot();\n    }\n\n    @Override\n    public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {\n        super.onViewCreated(view, savedInstanceState);\n\n        // Obtenemos el ViewModel (persistente durante el ciclo de vida de la Activity, por ello usamos requireActivity)\n        // highlight-next-line\n        viewModel = new ViewModelProvider(requireActivity()).get(AnimalesViewModel.class);\n\n        // Configuramos el RecyclerView y su adaptador\n        // Ahora pasamos una lista vac\xeda al constructor (podr\xedamos quitar ese par\xe1metro tambi\xe9n)\n        // highlight-next-line\n        adapter = new AnimalesAdapter(requireContext(), new ArrayList<>());\n        binding.recyclerView.setAdapter(adapter);\n        binding.recyclerView.setLayoutManager(new GridLayoutManager(requireContext(), 2));\n\n        // Observamos los datos del LiveData\n        // highlight-start\n        viewModel.animales.observe(getViewLifecycleOwner(), lista -> {\n            // Si hay cambios, actualizamos la lista del adaptador del RecyclerView\n            adapter.establecerLista(lista);\n        });\n\n        // Llamamos al m\xe9todo que recupera los animales\n        viewModel.obtenerAnimales();\n        // highlight-end\n    }\n}\n"})}),(0,l.jsxs)(a.admonition,{title:"Explicaci\xf3n del observer",type:"info",children:[(0,l.jsx)(a.p,{children:"La l\xednea:"}),(0,l.jsx)(a.pre,{children:(0,l.jsx)(a.code,{className:"language-java",children:"viewModel.animales.observe(getViewLifecycleOwner(), lista -> {\n    adapter.establecerLista(lista);\n});\n"})}),(0,l.jsxs)(a.p,{children:["establece un ",(0,l.jsx)(a.strong,{children:"observador"})," sobre el ",(0,l.jsx)(a.code,{children:"LiveData"})," del ",(0,l.jsx)(a.code,{children:"ViewModel"}),".\nEsto significa que el fragmento ",(0,l.jsx)(a.strong,{children:"se suscribe"})," a los cambios de datos que emite el ",(0,l.jsx)(a.code,{children:"MutableLiveData"})," ",(0,l.jsx)(a.code,{children:"animales"}),"."]}),(0,l.jsx)(a.p,{children:(0,l.jsx)(a.strong,{children:"\xbfQu\xe9 ocurre en tiempo de ejecuci\xf3n?"})}),(0,l.jsxs)(a.ol,{children:["\n",(0,l.jsxs)(a.li,{children:["\n",(0,l.jsxs)(a.p,{children:[(0,l.jsx)(a.strong,{children:"El Fragment se crea"})," y se suscribe al ",(0,l.jsx)(a.code,{children:"LiveData"})," mediante ",(0,l.jsx)(a.code,{children:"observe()"}),".\nEl m\xe9todo recibe dos par\xe1metros:"]}),"\n",(0,l.jsxs)(a.ul,{children:["\n",(0,l.jsxs)(a.li,{children:[(0,l.jsx)(a.code,{children:"getViewLifecycleOwner()"})," \u2192 controla que el observer est\xe9 activo solo mientras el Fragment est\xe1 visible."]}),"\n",(0,l.jsxs)(a.li,{children:["Una funci\xf3n lambda que se ejecuta ",(0,l.jsx)(a.strong,{children:"cada vez que cambian los datos"})," y que recibe la lista actualizada."]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(a.li,{children:["\n",(0,l.jsxs)(a.p,{children:[(0,l.jsx)(a.strong,{children:"El ViewModel actualiza el MutableLiveData"}),", por ejemplo:"]}),"\n",(0,l.jsx)(a.pre,{children:(0,l.jsx)(a.code,{className:"language-java",children:"animales.setValue(repository.getAnimales());\n"})}),"\n"]}),"\n",(0,l.jsxs)(a.li,{children:["\n",(0,l.jsxs)(a.p,{children:[(0,l.jsx)(a.strong,{children:"LiveData notifica autom\xe1ticamente"})," a todos los observadores activos (en este caso, el Fragment)."]}),"\n"]}),"\n",(0,l.jsxs)(a.li,{children:["\n",(0,l.jsxs)(a.p,{children:["El ",(0,l.jsx)(a.strong,{children:"c\xf3digo dentro del observer"})," se ejecuta:"]}),"\n",(0,l.jsx)(a.pre,{children:(0,l.jsx)(a.code,{className:"language-java",children:"adapter.establecerLista(lista);\n"})}),"\n",(0,l.jsx)(a.p,{children:"Dentro de ese m\xe9todo del adaptador:"}),"\n",(0,l.jsx)(a.pre,{children:(0,l.jsx)(a.code,{className:"language-java",children:"public void establecerLista(List<Animal> animales) {\n    this.animales = animales;\n    notifyDataSetChanged(); // Notifica al RecyclerView que los datos cambiaron\n}\n"})}),"\n",(0,l.jsxs)(a.p,{children:["El ",(0,l.jsx)(a.code,{children:"RecyclerView"})," recibe el aviso y ",(0,l.jsx)(a.strong,{children:"redibuja autom\xe1ticamente"})," las tarjetas en pantalla."]}),"\n"]}),"\n"]}),(0,l.jsx)(a.p,{children:"Cada capa tiene su funci\xf3n:"}),(0,l.jsxs)(a.ul,{children:["\n",(0,l.jsxs)(a.li,{children:["El ",(0,l.jsx)(a.strong,{children:"Repository"})," obtiene los datos."]}),"\n",(0,l.jsxs)(a.li,{children:["El ",(0,l.jsx)(a.strong,{children:"ViewModel"})," los actualiza en el LiveData."]}),"\n",(0,l.jsxs)(a.li,{children:["El ",(0,l.jsx)(a.strong,{children:"Fragment"})," observa y reenv\xeda los datos al Adapter."]}),"\n",(0,l.jsxs)(a.li,{children:["El ",(0,l.jsx)(a.strong,{children:"Adapter"})," reemplaza la lista y notifica al RecyclerView."]}),"\n"]})]}),(0,l.jsx)(a.hr,{}),(0,l.jsx)(a.h2,{id:"tutorial-de-uso---navegaci\xf3n-pantalla-detalle",children:"Tutorial de uso - Navegaci\xf3n pantalla detalle"}),(0,l.jsxs)(a.p,{children:["En el tema anterior, la navegaci\xf3n entre fragments se realizaba ",(0,l.jsxs)(a.strong,{children:["enviando el objeto ",(0,l.jsx)(a.code,{children:"Animal"})," como argumento"]})," desde el ",(0,l.jsx)(a.code,{children:"RecyclerView"})," hasta el ",(0,l.jsx)(a.code,{children:"DetalleAnimalFragment"}),".",(0,l.jsx)(a.br,{}),"\n","En esta versi\xf3n con ",(0,l.jsx)(a.strong,{children:"MVVM"}),", aprovecharemos que el ",(0,l.jsx)(a.strong,{children:"ViewModel puede compartirse entre fragments"}),", lo que nos permite ",(0,l.jsx)(a.strong,{children:"mantener y compartir los datos sin necesidad de pasar argumentos expl\xedcitos."})]}),(0,l.jsx)(a.h3,{id:"modificar-el-viewmodel",children:"Modificar el ViewModel"}),(0,l.jsxs)(a.p,{children:["Hasta ahora, el ",(0,l.jsx)(a.code,{children:"AnimalesViewModel"})," gestionaba solo la lista de animales. Ahora a\xf1adiremos un nuevo campo para guardar el ",(0,l.jsx)(a.strong,{children:"animal seleccionado"}),", que podr\xe1 ser observado por cualquier fragmento."]}),(0,l.jsx)(a.pre,{children:(0,l.jsx)(a.code,{className:"language-java",metastring:'title="AnimalesViewModel.java',children:"public class AnimalesViewModel extends ViewModel {\n\n    private AnimalesRepository repository;\n    public MutableLiveData<List<Animal>> animales = new MutableLiveData<>();\n    // highlight-next-line\n    public MutableLiveData<Animal> animalSeleccionado = new MutableLiveData<>();\n\n    public AnimalesViewModel() {\n        repository = new AnimalesRepository();\n        animales.setValue(repository.getAnimales());\n    }\n\n    // M\xe9todo para guardar el animal seleccionado\n    // highlight-start\n    public void seleccionarAnimal(Animal animal) {\n        animalSeleccionado.setValue(animal);\n    }\n    // highlight-end\n}\n"})}),(0,l.jsx)(a.p,{children:"\ud83d\udcac Con este cambio:"}),(0,l.jsxs)(a.ul,{children:["\n",(0,l.jsxs)(a.li,{children:["El ",(0,l.jsx)(a.code,{children:"ViewModel"})," sigue gestionando la lista completa."]}),"\n",(0,l.jsxs)(a.li,{children:["Adem\xe1s, ",(0,l.jsx)(a.strong,{children:"almacena temporalmente"})," el ",(0,l.jsx)(a.code,{children:"Animal"})," que se haya pulsado."]}),"\n",(0,l.jsxs)(a.li,{children:["Otros fragments podr\xe1n observar ",(0,l.jsx)(a.code,{children:"animalSeleccionado"})," para mostrar los datos."]}),"\n"]}),(0,l.jsx)(a.hr,{}),(0,l.jsx)(a.h3,{id:"modificar-el-adaptador-para-seleccionar-el-elemento",children:"Modificar el adaptador para seleccionar el elemento"}),(0,l.jsxs)(a.p,{children:["Antes, el adaptador creaba un ",(0,l.jsx)(a.code,{children:"Bundle"})," y enviaba el objeto ",(0,l.jsx)(a.code,{children:"Animal"})," mediante ",(0,l.jsx)(a.code,{children:"Navigation"}),".",(0,l.jsx)(a.br,{}),"\n","Ahora simplemente ",(0,l.jsxs)(a.strong,{children:["recibir\xe1 el ",(0,l.jsx)(a.code,{children:"ViewModel"})," en su constructor"]}),", notificar\xe1 al ViewModel del elemento pulsado y luego navegar\xe1 al fragmento de detalle."]}),(0,l.jsx)(a.pre,{children:(0,l.jsx)(a.code,{className:"language-java",metastring:'title="AnimalesAdapter.java"',children:"public class AnimalesAdapter extends RecyclerView.Adapter<AnimalesAdapter.AnimalViewHolder> {\n\n    private List<Animal> animales;\n    private AnimalesViewModel viewModel;\n    private final LayoutInflater inflater;\n\n    // highlight-start\n    public AnimalesAdapter(Context context, List<Animal> animales, AnimalesViewModel viewModel) {\n        this.animales = animales;\n        this.viewModel = viewModel;\n        this.inflater = LayoutInflater.from(context);\n    }\n    // highlight-end\n\n    @Override\n    public void onBindViewHolder(@NonNull AnimalViewHolder holder, int position) {\n        Animal animal = animales.get(position);\n        holder.binding.tvNombre.setText(animal.getNombre());\n        holder.binding.ivAnimal.setImageResource(animal.getImagen());\n\n        // highlight-start\n        holder.itemView.setOnClickListener(v -> {\n            // Guardamos el animal seleccionado en el ViewModel\n            viewModel.seleccionarAnimal(animal);\n\n            // Navegamos al fragmento de detalle (ya no eviamos Bundle)\n            NavController navController = Navigation.findNavController(v);\n            navController.navigate(R.id.action_animalesFragment_to_detalleAnimalFragment);\n        });\n        // highlight-end\n    }\n\n    // Resto del c\xf3digo del adapter (ViewHolder, establecerLista, etc.)\n}\n"})}),(0,l.jsxs)(a.p,{children:["Recuerda que ahora en el ",(0,l.jsx)(a.code,{children:"AnimalesFragment"})," debemos pasar el ",(0,l.jsx)(a.code,{children:"ViewModel"})," al crear el adaptador:"]}),(0,l.jsx)(a.pre,{children:(0,l.jsx)(a.code,{className:"language-java",metastring:'title="AnimalesFragment.java"',children:"@Override\npublic void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {\n    super.onViewCreated(view, savedInstanceState);\n\n    // Obtenemos el ViewModel compartido\n    viewModel = new ViewModelProvider(requireActivity()).get(AnimalesViewModel.class);\n\n    // Creamos el adapter pas\xe1ndole el ViewModel\n    // highlight-next-line\n    adapter = new AnimalesAdapter(requireContext(), new ArrayList<>(), viewModel);\n    binding.recyclerView.setLayoutManager(new GridLayoutManager(requireContext(), 2));\n    binding.recyclerView.setAdapter(adapter);\n\n    // Observamos los datos del LiveData\n    viewModel.animales.observe(getViewLifecycleOwner(), lista -> {\n        adapter.establecerLista(lista);\n    });\n}\n"})}),(0,l.jsx)(a.hr,{}),(0,l.jsx)(a.h3,{id:"recuperar-el-objeto-desde-el-fragmento-de-detalle",children:"Recuperar el objeto desde el fragmento de detalle"}),(0,l.jsxs)(a.p,{children:["En lugar de recibir los datos por argumentos, el ",(0,l.jsx)(a.code,{children:"DetalleAnimalFragment"})," observar\xe1 el ",(0,l.jsx)(a.code,{children:"LiveData"})," del ViewModel compartido y mostrar\xe1 el animal seleccionado."]}),(0,l.jsx)(a.pre,{children:(0,l.jsx)(a.code,{className:"language-java",metastring:'title="DetalleAnimalFragment.java"',children:'public class DetalleAnimalFragment extends Fragment {\n\n    private FragmentDetalleAnimalBinding binding;\n    private AnimalesViewModel viewModel;\n\n    @Override\n    public View onCreateView(LayoutInflater inflater, ViewGroup container,\n                             Bundle savedInstanceState) {\n        binding = FragmentDetalleAnimalBinding.inflate(inflater, container, false);\n        return binding.getRoot();\n    }\n\n    @Override\n    public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {\n        super.onViewCreated(view, savedInstanceState);\n\n        // Obtenemos el ViewModel compartido (misma instancia que en AnimalesFragment)\n        viewModel = new ViewModelProvider(requireActivity()).get(AnimalesViewModel.class);\n\n        // Observamos el animal seleccionado\n        viewModel.animalSeleccionado.observe(getViewLifecycleOwner(), animal -> {\n            if (animal != null) {\n                // Si ha llegado un animal, cargamos sus datos en el layout\n                binding.tvNombreDetalle.setText(animal.getNombre());\n                binding.ivDetalle.setImageResource(animal.getImagen());\n                binding.tvDescripcion.setText(animal.getDescripcion());\n            } else {\n                // En caso de error, podr\xedamos volver atr\xe1s o mostrar un mensaje\n                Toast.makeText(requireContext(), "No se pudo cargar el detalle del animal", Toast.LENGTH_SHORT).show();\n                requireActivity().onBackPressed();\n            }\n        });\n    }\n}\n'})}),(0,l.jsxs)(a.admonition,{title:"INSTANCIA DE VIEWMODEL",type:"info",children:[(0,l.jsxs)(a.p,{children:["\ud83d\udcac Aqu\xed, el ",(0,l.jsx)(a.strong,{children:"ViewModel es compartido entre fragments"}),", porque se obtiene con:"]}),(0,l.jsx)(a.pre,{children:(0,l.jsx)(a.code,{className:"language-java",children:"new ViewModelProvider(requireActivity()).get(AnimalesViewModel.class);\n"})}),(0,l.jsxs)(a.p,{children:["Esto garantiza que ambos fragments utilicen ",(0,l.jsx)(a.strong,{children:"la misma instancia"}),", manteniendo los datos sincronizados."]})]}),(0,l.jsx)(a.hr,{}),(0,l.jsx)(a.h3,{id:"modificaciones-en-el-grafo-de-navegaci\xf3n",children:"Modificaciones en el grafo de navegaci\xf3n"}),(0,l.jsxs)(a.p,{children:["Ya no es necesario pasar argumentos al fragmento de detalle.\nPodemos ",(0,l.jsxs)(a.strong,{children:["eliminar el argumento ",(0,l.jsx)(a.code,{children:"animal"})]})," del ",(0,l.jsx)(a.code,{children:"nav_graph.xml"}),", quedando as\xed:"]}),(0,l.jsx)(a.pre,{children:(0,l.jsx)(a.code,{className:"language-xml",metastring:'title="nav_graph.xml (fragmento simplificado)"',children:'<fragment\n    android:id="@+id/animalesFragment"\n    android:name="es.iesagora.demomvvm.AnimalesFragment"\n    android:label="Animales"\n    tools:layout="@layout/fragment_animales" >\n    <action\n        android:id="@+id/action_animalesFragment_to_detalleAnimalFragment"\n        app:destination="@id/detalleAnimalFragment" />\n</fragment>\n\n<fragment\n    android:id="@+id/detalleAnimalFragment"\n    android:name="es.iesagora.demomvvm.DetalleAnimalFragment"\n    android:label="Detalle animal"\n    tools:layout="@layout/fragment_detalle_animal" />\n'})}),(0,l.jsx)(a.hr,{}),(0,l.jsx)(a.h2,{id:"tutorial-de-uso--eliminar-un-elemento-mediante-gestos",children:"Tutorial de uso \u2013 Eliminar un elemento mediante gestos"}),(0,l.jsxs)(a.p,{children:["En el tema anterior aprendimos a eliminar un elemento del ",(0,l.jsx)(a.code,{children:"RecyclerView"})," deslizando el dedo hacia la izquierda o derecha.",(0,l.jsx)(a.br,{}),"\n","En aquella versi\xf3n, el ",(0,l.jsx)(a.code,{children:"Fragment"})," acced\xeda directamente al ",(0,l.jsx)(a.code,{children:"Repository"})," para eliminar el animal y luego avisaba al adaptador."]}),(0,l.jsxs)(a.p,{children:["Con ",(0,l.jsx)(a.strong,{children:"MVVM"}),", esa l\xf3gica cambia:",(0,l.jsx)(a.br,{}),"\n","ahora el ",(0,l.jsx)(a.strong,{children:(0,l.jsx)(a.code,{children:"ViewModel"})})," es el responsable de eliminar el elemento y ",(0,l.jsxs)(a.strong,{children:["actualizar el ",(0,l.jsx)(a.code,{children:"LiveData"})]}),", que a su vez ",(0,l.jsx)(a.strong,{children:"notificar\xe1 autom\xe1ticamente a la vista"})," para refrescar el ",(0,l.jsx)(a.code,{children:"RecyclerView"}),"."]}),(0,l.jsx)(a.h3,{id:"l\xf3gica-de-eliminaci\xf3n-en-el-viewmodel",children:"L\xf3gica de eliminaci\xf3n en el ViewModel"}),(0,l.jsxs)(a.p,{children:["El ",(0,l.jsx)(a.code,{children:"ViewModel"})," centraliza ahora la operaci\xf3n de borrado. Cada vez que eliminamos un animal, el ",(0,l.jsx)(a.code,{children:"ViewModel"})," actualiza el ",(0,l.jsx)(a.code,{children:"MutableLiveData"}),", y la vista recibe la nueva lista autom\xe1ticamente."]}),(0,l.jsx)(a.pre,{children:(0,l.jsx)(a.code,{className:"language-java",metastring:'title="AnimalesViewModel.java (fragmento)"',children:"public class AnimalesViewModel extends ViewModel {\n\n    private AnimalesRepository repository;\n    public MutableLiveData<List<Animal>> animales = new MutableLiveData<>();\n\n    public AnimalesViewModel() {\n        repository = new AnimalesRepository();\n        animales.setValue(repository.getAnimales());\n    }\n\n    // highlight-start\n    // Elimina un animal del repositorio y actualiza el LiveData\n    public void eliminarAnimal(int position) {\n        // Obtenemos la lista actual del LiveData\n        List<Animal> listaActual = animales.getValue();\n\n        // Comprobamos que la lista existe y que la posici\xf3n es v\xe1lida\n        if (listaActual != null && position >= 0 && position < listaActual.size()) {\n\n            // Recuperamos el animal que queremos eliminar\n            Animal eliminado = listaActual.get(position);\n\n            // Lo eliminamos del repositorio (fuente de datos)\n            repository.eliminarAnimal(eliminado);\n\n            // Actualizamos el LiveData con la nueva lista\n            animales.setValue(repository.getAnimales());\n        }\n    }\n    // highlight-end\n}\n"})}),(0,l.jsxs)(a.admonition,{type:"info",children:[(0,l.jsx)(a.p,{children:"Recuerda que en Repository ten\xedamos este m\xe9todo:"}),(0,l.jsx)(a.pre,{children:(0,l.jsx)(a.code,{className:"language-java",metastring:'title="AnimalesRepository.java',children:"public void eliminarAnimal(Animal animal) {\n    listaAnimales.remove(animal);\n}\n"})})]}),(0,l.jsx)(a.hr,{}),(0,l.jsx)(a.h3,{id:"configurar-el-gesto-en-el-fragment",children:"Configurar el gesto en el Fragment"}),(0,l.jsxs)(a.p,{children:["El ",(0,l.jsx)(a.code,{children:"ItemTouchHelper"})," sigue siendo el mecanismo que detecta el gesto de deslizamiento, pero ahora delegamos la acci\xf3n en el ",(0,l.jsx)(a.code,{children:"ViewModel"}),"."]}),(0,l.jsx)(a.pre,{children:(0,l.jsx)(a.code,{className:"language-java",metastring:'title="AnimalesFragment.java (fragmento modificado)"',children:"private void eventoEliminarElto(View view) {\n    ItemTouchHelper.SimpleCallback callback = new ItemTouchHelper.SimpleCallback(\n            0, // No se permite mover (drag)\n            ItemTouchHelper.LEFT | ItemTouchHelper.RIGHT // Permite deslizar\n    ) {\n        @Override\n        public boolean onMove(@NonNull RecyclerView recyclerView,\n                              @NonNull RecyclerView.ViewHolder viewHolder,\n                              @NonNull RecyclerView.ViewHolder target) {\n            return false; // No necesitamos movimiento\n        }\n\n        @Override\n        public void onSwiped(@NonNull RecyclerView.ViewHolder viewHolder, int direction) {\n            int position = viewHolder.getBindingAdapterPosition();\n\n            if (position != RecyclerView.NO_POSITION) {\n                // Pedimos al ViewModel que elimine el animal de esa posici\xf3n\n                // highlight-next-line\n                viewModel.eliminarAnimal(position);\n            }\n        }\n    };\n\n    // Asociamos el callback al RecyclerView\n    new ItemTouchHelper(callback).attachToRecyclerView(binding.recyclerView);\n}\n"})}),(0,l.jsx)(a.admonition,{title:"\xbfQu\xe9 ocurre paso a paso?",type:"info",children:(0,l.jsxs)(a.ol,{children:["\n",(0,l.jsxs)(a.li,{children:["El usuario desliza una tarjeta del ",(0,l.jsx)(a.code,{children:"RecyclerView"}),"."]}),"\n",(0,l.jsxs)(a.li,{children:["El ",(0,l.jsx)(a.code,{children:"ItemTouchHelper"})," detecta el gesto y llama a ",(0,l.jsx)(a.code,{children:"onSwiped()"}),"."]}),"\n",(0,l.jsxs)(a.li,{children:["El ",(0,l.jsx)(a.code,{children:"Fragment"})," obtiene la posici\xf3n del elemento y llama a ",(0,l.jsx)(a.code,{children:"viewModel.eliminarAnimal()"}),"."]}),"\n",(0,l.jsxs)(a.li,{children:["El ",(0,l.jsx)(a.code,{children:"ViewModel"})," actualiza el ",(0,l.jsx)(a.code,{children:"MutableLiveData"})," con la lista de animales."]}),"\n",(0,l.jsxs)(a.li,{children:["El ",(0,l.jsx)(a.code,{children:"LiveData"})," notifica al ",(0,l.jsx)(a.code,{children:"Fragment"}),", que actualiza la lista a trav\xe9s del ",(0,l.jsx)(a.code,{children:"Adapter"}),"."]}),"\n",(0,l.jsxs)(a.li,{children:["El ",(0,l.jsx)(a.code,{children:"RecyclerView"})," redibuja la lista sin el elemento eliminado."]}),"\n"]})}),(0,l.jsx)(a.hr,{}),(0,l.jsx)(a.h2,{id:"tutorial-de-uso--marcar-como-favorito",children:"Tutorial de uso \u2013 Marcar como favorito"}),(0,l.jsxs)(a.p,{children:["En este apartado aprenderemos a ",(0,l.jsx)(a.strong,{children:"marcar y desmarcar animales como favoritos"}),", lo que supone incorporar:"]}),(0,l.jsxs)(a.ul,{children:["\n",(0,l.jsxs)(a.li,{children:["Un atributo booleano ",(0,l.jsx)(a.code,{children:"favorito"})," en el modelo (clase ",(0,l.jsx)(a.code,{children:"Animal"}),")"]}),"\n",(0,l.jsxs)(a.li,{children:["Un icono que cambia en el ",(0,l.jsx)(a.code,{children:"ViewHolder"}),"."]}),"\n",(0,l.jsxs)(a.li,{children:["El ",(0,l.jsx)(a.code,{children:"ViewModel"})," actua de intermediario entre la vista (",(0,l.jsx)(a.code,{children:"Adapter"}),") y el ",(0,l.jsx)(a.code,{children:"Repository"}),"."]}),"\n",(0,l.jsxs)(a.li,{children:["El ",(0,l.jsx)(a.code,{children:"Fragment"})," observa los datos."]}),"\n"]}),(0,l.jsx)(a.p,{children:(0,l.jsx)(a.img,{alt:"Demo favorito",src:i(75533).A+"",width:"374",height:"822"})}),(0,l.jsx)(a.hr,{}),(0,l.jsx)(a.h3,{id:"modificar-el-layout-del-viewholder",children:"Modificar el layout del ViewHolder"}),(0,l.jsx)(a.p,{children:"Dentro del ViewHolder tenemos que incorporar el icono de favorito. Como imagen podemos utilizar una de las que nos proporciona Android."}),(0,l.jsx)(a.p,{children:"Ejemplo de layout:"}),(0,l.jsx)(a.pre,{children:(0,l.jsx)(a.code,{className:"language-xml",metastring:'title="viewholder_animal.xml"',children:'<?xml version="1.0" encoding="utf-8"?>\n<com.google.android.material.card.MaterialCardView xmlns:android="http://schemas.android.com/apk/res/android"\n    xmlns:app="http://schemas.android.com/apk/res-auto"\n    android:layout_width="match_parent"\n    android:layout_height="wrap_content"\n    android:layout_margin="8dp"\n    app:cardCornerRadius="12dp"\n    app:cardElevation="4dp">\n\n    \x3c!-- Contenedor para posicionar el icono arriba a la derecha --\x3e\n    <RelativeLayout\n        android:layout_width="match_parent"\n        android:layout_height="wrap_content"\n        android:padding="8dp">\n\n        \x3c!-- Icono de favorito --\x3e\n        <ImageView\n            android:id="@+id/icon_favorite"\n            android:layout_width="28dp"\n            android:layout_height="28dp"\n            android:layout_alignParentEnd="true"\n            android:layout_alignParentTop="true"\n            android:src="@android:drawable/btn_star_big_off"\n            android:clickable="true"\n            android:focusable="true" />\n\n        \x3c!-- Contenedor del contenido --\x3e\n        <LinearLayout\n            android:id="@+id/contenedorAnimal"\n            android:layout_width="match_parent"\n            android:layout_height="wrap_content"\n            android:orientation="vertical"\n            android:gravity="center_horizontal"\n            android:layout_marginTop="4dp"\n            android:layout_below="@id/icon_favorite">\n\n            <ImageView\n                android:id="@+id/ivAnimal"\n                android:layout_width="120dp"\n                android:layout_height="120dp" />\n\n            <TextView\n                android:id="@+id/tvNombre"\n                android:layout_width="wrap_content"\n                android:layout_height="wrap_content"\n                android:layout_marginTop="8dp"\n                android:textSize="18sp"\n                android:textStyle="bold" />\n        </LinearLayout>\n\n    </RelativeLayout>\n\n</com.google.android.material.card.MaterialCardView>\n'})}),(0,l.jsxs)(a.admonition,{title:"Iconos de favoritos (estrella)",type:"info",children:[(0,l.jsxs)(a.p,{children:["Los recursos ",(0,l.jsxs)(a.strong,{children:["@android",":drawable","/btn_star_big_off"]})," y ",(0,l.jsxs)(a.strong,{children:["@android",":drawable","/btn_star_big_on"]})," son iconos est\xe1ndar incluidos en Android:"]}),(0,l.jsxs)(a.ul,{children:["\n",(0,l.jsxs)(a.li,{children:[(0,l.jsx)(a.strong,{children:(0,l.jsx)(a.code,{children:"btn_star_big_off"})})," \u2192 \u2b50 ",(0,l.jsx)(a.em,{children:"estrella gris"})," \u2192 indica que ",(0,l.jsx)(a.strong,{children:"no es favorito"}),"."]}),"\n",(0,l.jsxs)(a.li,{children:[(0,l.jsx)(a.strong,{children:(0,l.jsx)(a.code,{children:"btn_star_big_on"})})," \u2192 \u2b50 ",(0,l.jsx)(a.em,{children:"estrella amarilla"})," \u2192 indica que ",(0,l.jsx)(a.strong,{children:"s\xed es favorito"}),"."]}),"\n"]}),(0,l.jsx)(a.p,{children:"Estos iconos son perfectos para marcar / desmarcar favoritos sin necesidad de a\xf1adir im\xe1genes externas al proyecto."})]}),(0,l.jsx)(a.hr,{}),(0,l.jsxs)(a.h3,{id:"modificar-el-modelo-animaljava",children:["Modificar el modelo (",(0,l.jsx)(a.code,{children:"Animal.java"}),")"]}),(0,l.jsxs)(a.p,{children:["A\xf1adimos un atributo ",(0,l.jsx)(a.code,{children:"boolean esFavorito"}),", que determinar\xe1 eis el Pokemon se ha marcado como favorito o no."]}),(0,l.jsx)(a.pre,{children:(0,l.jsx)(a.code,{className:"language-java",children:"public class Animal {\n    private String nombre;\n    private int imagen;\n    private String descripcion;\n    // highlight-next-line\n    private boolean favorito;\n\n    public Animal(String nombre, int imagen, String descripcion) {\n        this.nombre = nombre;\n        this.imagen = imagen;\n        this.descripcion = descripcion;\n        // highlight-next-line\n        this.favorito = false; // Por defecto no es favorito\n    }\n\n    // highlight-start\n    public boolean isFavorito() {\n        return favorito;\n    }\n\n    public void setFavorito(boolean favorito) {\n        this.favorito = favorito;\n    }\n    // highlight-start\n\n    // Resto del c\xf3digo que ya tuvieras...\n}\n"})}),(0,l.jsx)(a.hr,{}),(0,l.jsx)(a.h3,{id:"cambios-en-el-adapter",children:"Cambios en el Adapter"}),(0,l.jsxs)(a.p,{children:["En el adaptador es donde conectamos cada elemento de la lista con su tarjeta visual.\nPara a\xf1adir la funcionalidad de \u201cfavoritos\u201d, el m\xe9todo ",(0,l.jsx)(a.code,{children:"onBindViewHolder()"})," debe hacer dos cosas adicionales:"]}),(0,l.jsxs)(a.ul,{children:["\n",(0,l.jsxs)(a.li,{children:["\n",(0,l.jsxs)(a.p,{children:[(0,l.jsx)(a.strong,{children:"Mostrar el icono correcto"}),": cuando se carga cada tarjeta, debe comprobar si el animal es favorito y poner la estrella encendida o apagada (m\xe9todo ",(0,l.jsx)(a.code,{children:"establecerIconoFavorito"}),")."]}),"\n"]}),"\n",(0,l.jsxs)(a.li,{children:["\n",(0,l.jsxs)(a.p,{children:[(0,l.jsx)(a.strong,{children:"Responder al click en la estrella"}),": si se pulsa el icono, el adaptador debe cambiar el estado del animal, actualizar el icono y avisar al ",(0,l.jsx)(a.code,{children:"ViewModel"})," para que guarde el cambio en base de datos, que para nosotros de momento ser\xe1 el repository."]}),"\n"]}),"\n"]}),(0,l.jsxs)(a.p,{children:["De esta forma, el adaptador se encarga tanto de mostrar la informaci\xf3n como de reaccionar a las acciones del usuario, mientras que el ",(0,l.jsx)(a.code,{children:"ViewModel"})," mantiene el estado actualizado."]}),(0,l.jsx)(a.pre,{children:(0,l.jsx)(a.code,{className:"language-java",metastring:'title="AnimalesAdapter.java"',children:"public class AnimalesAdapter extends RecyclerView.Adapter<AnimalesAdapter.AnimalViewHolder> {\n\n    // Aqu\xed va el c\xf3digo que ya ten\xedas...\n\n    // Rellena los datos en el ViewHolder correspondiente a una posici\xf3n concreta\n    @Override\n    public void onBindViewHolder(@NonNull AnimalViewHolder holder, int position) {\n        Animal animal = animales.get(position);\n\n        // Enlazamos los datos con los elementos del layout\n        holder.binding.tvNombre.setText(animal.getNombre());\n        holder.binding.ivAnimal.setImageResource(animal.getImagen());\n\n        // Detectar el click sobre la tarjeta\n        holder.itemView.setOnClickListener(v -> {\n            // Guardamos el animal seleccionado en el ViewModel\n            viewModel.seleccionarAnimal(animal);\n\n            // Navegar al fragmento de detalle usando NavController\n            NavController navController = Navigation.findNavController(v);\n            navController.navigate(R.id.action_animalesFragment_to_detalleAnimalFragment);\n        });\n\n        // highlight-start\n        // Cuando se cargue el RecyclerView, actualizamos el icono seg\xfan el estado del animal\n        establecerIconoFavorito(animal, holder);\n\n        // Listener para el evento sobre el icono de favorito\n        holder.binding.iconFavorite.setOnClickListener(v -> marcarFavorito(animal, holder));\n        // highlight-end\n    }\n\n    // highlight-start\n    // M\xe9todo que se ejecuta en el evento de click sobre la estrella\n    private void marcarFavorito(Animal animal, AnimalViewHolder holder) {\n        // Cambiamos el estado del animal seleccionado\n        if (animal.isFavorito()) animal.setFavorito(false);\n        else animal.setFavorito(true);\n\n        // Cambiamos el icono del animal seleccionado\n        establecerIconoFavorito(animal, holder);\n\n        // Actualizamos el estado del animal en base de datos (de momento el repository)\n        // Recuerda que no podemos acceder al repository directamente, si no a trav\xe9s del ViewModel\n        viewModel.actualizarAnimal(animal);\n    }\n\n    // M\xe9todo que establece el icono seg\xfan el estado del animal\n    private void establecerIconoFavorito(Animal animal, AnimalViewHolder holder) {\n        if (animal.isFavorito()) {\n            holder.binding.iconFavorite.setImageResource(android.R.drawable.btn_star_big_on);\n        } else {\n            holder.binding.iconFavorite.setImageResource(android.R.drawable.btn_star_big_off);\n        }\n    }\n    // highlight-end\n}\n"})}),(0,l.jsx)(a.hr,{}),(0,l.jsx)(a.h3,{id:"gestionar-favoritos-en-el-viewmodel-y-repisitory",children:"Gestionar favoritos en el ViewModel y Repisitory"}),(0,l.jsxs)(a.p,{children:["El ",(0,l.jsx)(a.strong,{children:"ViewModel"})," act\xfaa como puente entre la vista y el Repository.\nCuando el usuario pulsa la estrella y cambia el estado de un animal, el ViewModel recibe el objeto actualizado y se lo pasa al Repository para que lo guarde:"]}),(0,l.jsx)(a.pre,{children:(0,l.jsx)(a.code,{className:"language-java",metastring:'title="AnimalesViewModel.java"',children:"public class AnimalesViewModel extends ViewModel {\n\n    // C\xf3digo previo...\n\n    public void actualizarAnimal(Animal animal) {\n        repository.actualizarAnimal(animal);\n    }\n}\n"})}),(0,l.jsxs)(a.p,{children:["En el ",(0,l.jsx)(a.strong,{children:"Repository"})," es donde realmente se modifican los datos.\nPara evitar que el animal cambie de posici\xf3n en la lista (y por tanto en el RecyclerView), primero buscamos su \xedndice y luego lo reemplazamos por la versi\xf3n actualizada:"]}),(0,l.jsx)(a.pre,{children:(0,l.jsx)(a.code,{className:"language-java",children:"public class AnimalesRepository {\n\n    private List<Animal> listaAnimales;\n\n    // C\xf3digo previo...\n\n    public void actualizarAnimal(Animal animal) {\n        // Recuperamos la posici\xf3n previa para volver a colocarlo en el mismo sitio\n        int posicion = listaAnimales.indexOf(animal);\n        // Colocamos el animal modificado en el mismo sitio\n        listaAnimales.set(posicion, animal);\n    }\n}\n"})}),(0,l.jsx)(a.hr,{}),(0,l.jsx)(a.h2,{id:"tutorial-de-uso--b\xfasqueda-de-elementos",children:"Tutorial de uso \u2013 B\xfasqueda de elementos"}),(0,l.jsxs)(a.p,{children:["La b\xfasqueda es una de las funciones m\xe1s \xfatiles cuando trabajamos con listas grandes de datos.\nEn este apartado aprenderemos a implementar un campo de b\xfasqueda que filtre la lista de animales ",(0,l.jsx)(a.strong,{children:"mientras el usuario escribe"}),", utilizando el mismo enfoque de MVVM que ya hemos aplicado en los apartados anteriores."]}),(0,l.jsx)(a.p,{children:"La idea principal es:"}),(0,l.jsxs)(a.ol,{children:["\n",(0,l.jsxs)(a.li,{children:["El usuario escribe en el ",(0,l.jsx)(a.code,{children:"SearchView"}),"."]}),"\n",(0,l.jsxs)(a.li,{children:["El ",(0,l.jsx)(a.code,{children:"Fragment"})," env\xeda el texto al ",(0,l.jsx)(a.code,{children:"ViewModel"}),"."]}),"\n",(0,l.jsxs)(a.li,{children:["El ",(0,l.jsx)(a.code,{children:"ViewModel"})," pide la lista filtrada al ",(0,l.jsx)(a.code,{children:"Repository"}),"."]}),"\n",(0,l.jsxs)(a.li,{children:["El ",(0,l.jsx)(a.code,{children:"LiveData"})," se actualiza y notifica al ",(0,l.jsx)(a.code,{children:"Fragment"}),"."]}),"\n",(0,l.jsxs)(a.li,{children:["El observer del ",(0,l.jsx)(a.code,{children:"Fragment"})," env\xeda la nueva lista al ",(0,l.jsx)(a.code,{children:"Adapter"})," y la muestra autom\xe1ticamente."]}),"\n"]}),(0,l.jsx)(a.p,{children:"As\xed mantenemos la separaci\xf3n de responsabilidades:"}),(0,l.jsxs)(a.p,{children:["\ud83d\udca1 ",(0,l.jsx)(a.strong,{children:"El Fragment solo escucha y env\xeda texto. El ViewModel act\xfaa como intermediario y el Repository hace la l\xf3gica de filtrado."})]}),(0,l.jsx)(a.p,{children:(0,l.jsx)(a.img,{alt:"Demo SearchView",src:i(30445).A+"",width:"374",height:"822"})}),(0,l.jsx)(a.hr,{}),(0,l.jsx)(a.h3,{id:"layout-con-searchview",children:"Layout con SearchView"}),(0,l.jsxs)(a.p,{children:["Creamos un layout similar al anterior, pero a\xf1adiendo un ",(0,l.jsx)(a.code,{children:"SearchView"})," editable desde el inicio:"]}),(0,l.jsx)(a.pre,{children:(0,l.jsx)(a.code,{className:"language-xml",metastring:'title="',children:'<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"\n    xmlns:tools="http://schemas.android.com/tools"\n    android:layout_width="match_parent"\n    android:layout_height="match_parent"\n    android:orientation="vertical"\n    android:padding="8dp"\n    tools:context=".AnimalesFragment">\n\n    \x3c!-- Barra de b\xfasqueda --\x3e\n    <SearchView\n        android:id="@+id/search_view"\n        android:layout_width="match_parent"\n        android:layout_height="wrap_content"\n        android:iconifiedByDefault="false"\n        android:queryHint="Buscar animal" />\n\n    \x3c!-- Lista --\x3e\n    <androidx.recyclerview.widget.RecyclerView\n        android:id="@+id/recycler_view"\n        android:layout_width="match_parent"\n        android:layout_height="match_parent" />\n\n</LinearLayout>\n'})}),(0,l.jsxs)(a.admonition,{title:"\xbfQu\xe9 es un SearchView?",type:"info",children:[(0,l.jsxs)(a.p,{children:[(0,l.jsx)(a.code,{children:"SearchView"})," es un componente de Android que permite al usuario escribir texto para realizar b\xfasquedas dentro de una lista o conjunto de datos.\nEs ideal para ",(0,l.jsx)(a.strong,{children:"filtrar resultados en tiempo real"}),", ya que detecta cada car\xe1cter escrito y puede enviarlo al ",(0,l.jsx)(a.code,{children:"ViewModel"})," para actualizar la informaci\xf3n mostrada."]}),(0,l.jsx)(a.p,{children:(0,l.jsx)(a.strong,{children:"Atributos XML m\xe1s \xfatiles:"})}),(0,l.jsxs)(a.ul,{children:["\n",(0,l.jsxs)(a.li,{children:[(0,l.jsx)(a.code,{children:'android:iconifiedByDefault="false"'})," \u2192 Hace que el cuadro de b\xfasqueda aparezca desplegado desde el inicio."]}),"\n",(0,l.jsxs)(a.li,{children:[(0,l.jsx)(a.code,{children:'android:queryHint="Texto de ayuda"'})," \u2192 Muestra un texto gu\xeda dentro del campo de b\xfasqueda."]}),"\n",(0,l.jsxs)(a.li,{children:[(0,l.jsx)(a.code,{children:"android:layout_width / layout_height"})," \u2192 Controlan el tama\xf1o del componente."]}),"\n",(0,l.jsxs)(a.li,{children:[(0,l.jsx)(a.code,{children:'android:focusable="true"'})," \u2192 Permite activar el teclado al tocar el campo."]}),"\n"]}),(0,l.jsx)(a.p,{children:"Estos atributos permiten personalizar f\xe1cilmente su apariencia y comportamiento."})]}),(0,l.jsx)(a.hr,{}),(0,l.jsx)(a.h3,{id:"activar-la-b\xfasqueda-desde-el-fragment",children:"Activar la b\xfasqueda desde el Fragment"}),(0,l.jsxs)(a.p,{children:["El ",(0,l.jsx)(a.code,{children:"Fragment"})," configura el RecyclerView, observa los cambios y escucha lo que escribe el usuario en tiempo real. Al c\xf3digo que ten\xedamos ya, debemos a\xf1adirle:"]}),(0,l.jsx)(a.pre,{children:(0,l.jsx)(a.code,{className:"language-java",children:"public class AnimalesFragment extends Fragment {\n\n    // C\xf3digo anterior\n\n    @Override\n    public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {\n        super.onViewCreated(view, savedInstanceState);\n\n        // C\xf3digo anterior\n\n        // Evento de b\xfasqueda sobre el searchView\n        binding.searchView.setOnQueryTextListener(new SearchView.OnQueryTextListener() {\n            \n            // M\xe9todo que se ejecuta cuando el usuario le da a intro\n            // No nos interesa implementarlo\n            @Override\n            public boolean onQueryTextSubmit(String query) {\n                return false;\n            }\n\n            // M\xe9todo que se ejecuta cada vez que el usuario escribe una letra en el searchView\n            @Override\n            public boolean onQueryTextChange(String texto) {\n                viewModel.buscarAnimalPorNombre(texto);\n                return true;\n            }\n        });\n    }\n}\n"})}),(0,l.jsx)(a.hr,{}),(0,l.jsx)(a.h3,{id:"filtrar-elementos-en-viewmodel-y-repository",children:"Filtrar elementos en ViewModel y Repository"}),(0,l.jsxs)(a.p,{children:["El ",(0,l.jsx)(a.code,{children:"ViewModel"})," act\xfaa como intermediario entre la vista y la capa de datos.\nCuando el usuario escribe en el ",(0,l.jsx)(a.code,{children:"SearchView"}),", el ",(0,l.jsx)(a.code,{children:"Fragment"})," env\xeda ese texto al ",(0,l.jsx)(a.code,{children:"ViewModel"}),", y este se encarga de pedir al ",(0,l.jsx)(a.code,{children:"Repository"})," la lista filtrada.\nDespu\xe9s, actualiza el ",(0,l.jsx)(a.code,{children:"MutableLiveData"})," para que el ",(0,l.jsx)(a.code,{children:"Fragment"})," reciba la nueva lista y el ",(0,l.jsx)(a.code,{children:"Adapter"})," pueda mostrarla autom\xe1ticamente."]}),(0,l.jsx)(a.pre,{children:(0,l.jsx)(a.code,{className:"language-java",metastring:'title="AnimalesViewModel"',children:"public class AnimalesViewModel extends ViewModel {\n\n    // Usamos el mismo LiveData que ya mostraba la lista completa\n    public MutableLiveData<List<Animal>> animales = new MutableLiveData<>();\n    \n    // C\xf3digo previo\n\n    // Recibe el texto del SearchView y pide al Repository la lista filtrada\n    public void buscarAnimalPorNombre(String texto) {\n        animales.setValue(repository.getAnimalesPorNombre(texto));\n    }\n}\n"})}),(0,l.jsxs)(a.p,{children:["Por su parte, el ",(0,l.jsx)(a.code,{children:"Repository"})," es el encargado de realizar el filtrado.\nAqu\xed es donde recorremos la lista original y seleccionamos solamente los animales cuyo nombre ",(0,l.jsx)(a.strong,{children:"comienza"})," por el texto introducido por el usuario:"]}),(0,l.jsx)(a.pre,{children:(0,l.jsx)(a.code,{className:"language-java",metastring:'title="AnimalesRepository"',children:"public class AnimalesRepository {\n\n    // C\xf3digo anterior\n\n    // Devuelve solo los animales cuyo nombre empieza por el texto indicado\n    public List<Animal> getAnimalesPorNombre(String texto) {\n        List<Animal> resultado = new ArrayList<>();\n        for (Animal a : listaAnimales) {\n            if (a.getNombre().toLowerCase().startsWith(texto)) {\n                resultado.add(a);\n            }\n        }\n        return resultado;\n    }\n}\n"})})]})}function m(e={}){const{wrapper:a}={...(0,r.R)(),...e.components};return a?(0,l.jsx)(a,{...e,children:(0,l.jsx)(c,{...e})}):c(e)}},75533:(e,a,i)=>{i.d(a,{A:()=>n});const n=i.p+"assets/images/demo-fav-3c7016d27aced45edb8f42eeb2481afc.gif"},92588:(e,a,i)=>{i.d(a,{A:()=>n});const n=i.p+"assets/images/ciclo-vida-vm-3d56f6694678be10f3d8dc1ce096ef04.png"}}]);